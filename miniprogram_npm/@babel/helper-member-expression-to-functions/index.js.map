{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = memberExpressionToFunctions;\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t().assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member) {\n    const {\n      node,\n      parent,\n      parentPath\n    } = member;\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t().binaryExpression(operator[0], t().unaryExpression(\"+\", this.get(member)), t().numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t().assignmentExpression(\"=\", t().cloneNode(ref), value.left);\n        parentPath.replaceWith(t().sequenceExpression([this.set(member, value), t().cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      const {\n        operator,\n        right\n      } = parent;\n      let value = right;\n\n      if (operator !== \"=\") {\n        this.memoise(member, 2);\n        value = t().binaryExpression(operator.slice(0, -1), this.get(member), value);\n      }\n\n      parentPath.replaceWith(this.set(member, value));\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      const {\n        arguments: args\n      } = parent;\n      parentPath.replaceWith(this.call(member, args));\n      return;\n    }\n\n    member.replaceWith(this.get(member));\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}"]}