{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\n\nfunction _helperFunctionName() {\n  const data = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\n  _helperFunctionName = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = _interopRequireDefault(require(\"@babel/template\"));\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst buildAnonymousExpressionWrapper = _template().default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\n\nconst buildNamedExpressionWrapper = _template().default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\n\nconst buildDeclarationWrapper = (0, _template().default)(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(path, callId) {\n  const node = path.node;\n  const body = node.body;\n  const container = t().functionExpression(null, [], t().blockStatement(body.body), true);\n  body.body = [t().returnStatement(t().callExpression(t().callExpression(callId, [container]), []))];\n  node.async = false;\n  node.generator = false;\n  path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(path, callId) {\n  const node = path.node;\n  const isDeclaration = path.isFunctionDeclaration();\n  const functionId = node.id;\n  const wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;\n\n  if (path.isArrowFunctionExpression()) {\n    path.arrowFunctionToExpression();\n  }\n\n  node.id = null;\n\n  if (isDeclaration) {\n    node.type = \"FunctionExpression\";\n  }\n\n  const built = t().callExpression(callId, [node]);\n  const container = wrapper({\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: node.params.reduce((acc, param) => {\n      acc.done = acc.done || t().isAssignmentPattern(param) || t().isRestElement(param);\n\n      if (!acc.done) {\n        acc.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n\n      return acc;\n    }, {\n      params: [],\n      done: false\n    }).params\n  });\n\n  if (isDeclaration) {\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    const retFunction = container.callee.body.body[1].argument;\n\n    if (!functionId) {\n      (0, _helperFunctionName().default)({\n        node: retFunction,\n        parent: path.parent,\n        scope: path.scope\n      });\n    }\n\n    if (!retFunction || retFunction.id || node.params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\n\nfunction wrapFunction(path, callId) {\n  if (path.isClassMethod() || path.isObjectMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(path, callId);\n  }\n}"]}