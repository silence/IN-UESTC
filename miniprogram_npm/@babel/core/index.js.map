{"version":3,"sources":["index.js","transformation/file/file.js","tools/build-external-helpers.js","config/files/index.js","config/files/package.js","config/files/utils.js","config/caching.js","config/files/configuration.js","config/helpers/config-api.js","config/pattern-to-regex.js","config/files/plugins.js","../package.json","config/helpers/environment.js","config/item.js","config/config-descriptors.js","config/index.js","config/full.js","config/util.js","config/plugin.js","config/config-chain.js","config/validation/options.js","config/validation/removed.js","config/validation/option-assertions.js","config/validation/plugins.js","config/partial.js","transform.js","transformation/index.js","transformation/plugin-pass.js","transformation/block-hoist-plugin.js","transformation/normalize-opts.js","transformation/normalize-file.js","transformation/util/missing-plugin-helper.js","transformation/file/generate.js","transformation/file/merge-map.js","transform-file.js","transform-ast.js","parse.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,AHSA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,AJYA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AELA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,AHSA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,ALeA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ARwBA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ARwBA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ARwBA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ACHA,AT2BA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ACHA,AT2BA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,ACHA,AGTA,ACHA,AT2BA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AKdA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,ACHA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,AHSA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,AHSA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,AHSA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,ACHA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,ACHA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AIZA,AGTA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AOrBA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AGTA,AOrBA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AT2BA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AQxBA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AQxBA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AQxBA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,ALeA,AWjCA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AQxBA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AjBmDA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ApB4DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ApB4DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ApB4DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AGTA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,ACHA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AJYA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AWjCA,Af6CA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AOrBA,AFMA,AWjCA,Af6CA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,Af6CA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,ADGA;AU7BA,ALeA,AavCA,ALeA,APqBA,AJYA,ACHA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,Af6CA,AS3BA,ADGA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA;AU7BA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,Af6CA,AQxBA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA;AU7BA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,Af6CA,AQxBA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA;AU7BA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,Af6CA,AQxBA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA;Af8CA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,APqBA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA;Af8CA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,APqBA,AKfA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA;Af8CA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AxBwEA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,ACHA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AHSA,AMlBA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AGTA,AFMA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AGTA,AFMA;AhBiDA,ALeA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AGTA,AFMA;ArBgEA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA;ArBgEA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA;ArBgEA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA;ArBgEA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,AyB3EA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ANkBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ANkBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ANkBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AuBrEA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AgChGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AgChGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AKfA,AWjCA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AgChGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AgBhDA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AgBhDA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AgBhDA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AENA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AgBhDA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,ARwBA,AgBhDA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,AGTA,AFMA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ACHA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ACHA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ACHA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,AT2BA,AGTA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ACHA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ACHA,ArB+DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AFMA,AIZA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AlCsGA,AiCnGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,ANkBA,A3BiFA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ADGA,AENA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,ADGA,ADGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AoC5GA,AFMA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,APqBA,AIZA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,A+B7FA,ACHA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,AkCtGA,AjCmGA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AGTA,AMlBA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AQxBA,AFMA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AzB4EA,AavCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,ApB4DA,ACHA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,AFMA,AnByDA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,ALeA,APqBA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,ArB+DA,AgChGA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AHSA,ACHA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AFMA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AFMA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AFMA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AFMA;AZqCA,AZoCA,AS3BA,AMlBA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA,AFMA;AZqCA,AZoCA,Ae7CA,AWjCA;Ad2CA,AZoCA,Ae7CA,AWjCA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,AZoCA,A0B9EA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA,Ac1CA;Ad2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Plugin = Plugin;\nObject.defineProperty(exports, \"File\", {\n  enumerable: true,\n  get: function () {\n    return _file.default;\n  }\n});\nObject.defineProperty(exports, \"buildExternalHelpers\", {\n  enumerable: true,\n  get: function () {\n    return _buildExternalHelpers.default;\n  }\n});\nObject.defineProperty(exports, \"resolvePlugin\", {\n  enumerable: true,\n  get: function () {\n    return _files.resolvePlugin;\n  }\n});\nObject.defineProperty(exports, \"resolvePreset\", {\n  enumerable: true,\n  get: function () {\n    return _files.resolvePreset;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _package.version;\n  }\n});\nObject.defineProperty(exports, \"getEnv\", {\n  enumerable: true,\n  get: function () {\n    return _environment.getEnv;\n  }\n});\nObject.defineProperty(exports, \"tokTypes\", {\n  enumerable: true,\n  get: function () {\n    return _parser().tokTypes;\n  }\n});\nObject.defineProperty(exports, \"traverse\", {\n  enumerable: true,\n  get: function () {\n    return _traverse().default;\n  }\n});\nObject.defineProperty(exports, \"template\", {\n  enumerable: true,\n  get: function () {\n    return _template().default;\n  }\n});\nObject.defineProperty(exports, \"createConfigItem\", {\n  enumerable: true,\n  get: function () {\n    return _item.createConfigItem;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfig\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadPartialConfig;\n  }\n});\nObject.defineProperty(exports, \"loadOptions\", {\n  enumerable: true,\n  get: function () {\n    return _config.loadOptions;\n  }\n});\nObject.defineProperty(exports, \"transform\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transform;\n  }\n});\nObject.defineProperty(exports, \"transformSync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformSync;\n  }\n});\nObject.defineProperty(exports, \"transformAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transform.transformAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFile\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFile;\n  }\n});\nObject.defineProperty(exports, \"transformFileSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileSync;\n  }\n});\nObject.defineProperty(exports, \"transformFileAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformFile.transformFileAsync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAst\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAst;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstSync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstSync;\n  }\n});\nObject.defineProperty(exports, \"transformFromAstAsync\", {\n  enumerable: true,\n  get: function () {\n    return _transformAst.transformFromAstAsync;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parse;\n  }\n});\nObject.defineProperty(exports, \"parseSync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseSync;\n  }\n});\nObject.defineProperty(exports, \"parseAsync\", {\n  enumerable: true,\n  get: function () {\n    return _parse.parseAsync;\n  }\n});\nexports.types = exports.OptionManager = exports.DEFAULT_EXTENSIONS = void 0;\n\nvar _file = _interopRequireDefault(require(\"./transformation/file/file\"));\n\nvar _buildExternalHelpers = _interopRequireDefault(require(\"./tools/build-external-helpers\"));\n\nvar _files = require(\"./config/files\");\n\nvar _package = require(\"../package.json\");\n\nvar _environment = require(\"./config/helpers/environment\");\n\nfunction _types() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  _types = function () {\n    return data;\n  };\n\n  return data;\n}\n\nObject.defineProperty(exports, \"types\", {\n  enumerable: true,\n  get: function () {\n    return _types();\n  }\n});\n\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n\n  _parser = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _traverse() {\n  const data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = _interopRequireDefault(require(\"@babel/template\"));\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _item = require(\"./config/item\");\n\nvar _config = require(\"./config\");\n\nvar _transform = require(\"./transform\");\n\nvar _transformFile = require(\"./transform-file\");\n\nvar _transformAst = require(\"./transform-ast\");\n\nvar _parse = require(\"./parse\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst DEFAULT_EXTENSIONS = Object.freeze([\".js\", \".jsx\", \".es6\", \".es\", \".mjs\"]);\nexports.DEFAULT_EXTENSIONS = DEFAULT_EXTENSIONS;\n\nclass OptionManager {\n  init(opts) {\n    return (0, _config.loadOptions)(opts);\n  }\n\n}\n\nexports.OptionManager = OptionManager;\n\nfunction Plugin(alias) {\n  throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction helpers() {\n  const data = _interopRequireWildcard(require(\"@babel/helpers\"));\n\n  helpers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _traverse() {\n  const data = _interopRequireWildcard(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n\n  _codeFrame = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _semver() {\n  const data = _interopRequireDefault(require(\"semver\"));\n\n  _semver = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst errorVisitor = {\n  enter(path, state) {\n    const loc = path.node.loc;\n\n    if (loc) {\n      state.loc = loc;\n      path.stop();\n    }\n  }\n\n};\n\nclass File {\n  constructor(options, {\n    code,\n    ast,\n    inputMap\n  }) {\n    this._map = new Map();\n    this.declarations = {};\n    this.path = null;\n    this.ast = {};\n    this.metadata = {};\n    this.code = \"\";\n    this.inputMap = null;\n    this.hub = {\n      file: this,\n      getCode: () => this.code,\n      getScope: () => this.scope,\n      addHelper: this.addHelper.bind(this),\n      buildError: this.buildCodeFrameError.bind(this)\n    };\n    this.opts = options;\n    this.code = code;\n    this.ast = ast;\n    this.inputMap = inputMap;\n    this.path = _traverse().NodePath.get({\n      hub: this.hub,\n      parentPath: null,\n      parent: this.ast,\n      container: this.ast,\n      key: \"program\"\n    }).setContext();\n    this.scope = this.path.scope;\n  }\n\n  get shebang() {\n    const {\n      interpreter\n    } = this.path.node;\n    return interpreter ? interpreter.value : \"\";\n  }\n\n  set shebang(value) {\n    if (value) {\n      this.path.get(\"interpreter\").replaceWith(t().interpreterDirective(value));\n    } else {\n      this.path.get(\"interpreter\").remove();\n    }\n  }\n\n  set(key, val) {\n    if (key === \"helpersNamespace\") {\n      throw new Error(\"Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.\" + \"If you are using @babel/plugin-external-helpers you will need to use a newer \" + \"version than the one you currently have installed. \" + \"If you have your own implementation, you'll want to explore using 'helperGenerator' \" + \"alongside 'file.availableHelper()'.\");\n    }\n\n    this._map.set(key, val);\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  getModuleName() {\n    const {\n      filename,\n      filenameRelative = filename,\n      moduleId,\n      moduleIds = !!moduleId,\n      getModuleId,\n      sourceRoot: sourceRootTmp,\n      moduleRoot = sourceRootTmp,\n      sourceRoot = moduleRoot\n    } = this.opts;\n    if (!moduleIds) return null;\n\n    if (moduleId != null && !getModuleId) {\n      return moduleId;\n    }\n\n    let moduleName = moduleRoot != null ? moduleRoot + \"/\" : \"\";\n\n    if (filenameRelative) {\n      const sourceRootReplacer = sourceRoot != null ? new RegExp(\"^\" + sourceRoot + \"/?\") : \"\";\n      moduleName += filenameRelative.replace(sourceRootReplacer, \"\").replace(/\\.(\\w*?)$/, \"\");\n    }\n\n    moduleName = moduleName.replace(/\\\\/g, \"/\");\n\n    if (getModuleId) {\n      return getModuleId(moduleName) || moduleName;\n    } else {\n      return moduleName;\n    }\n  }\n\n  addImport() {\n    throw new Error(\"This API has been removed. If you're looking for this \" + \"functionality in Babel 7, you should import the \" + \"'@babel/helper-module-imports' module and use the functions exposed \" + \" from that module, such as 'addNamed' or 'addDefault'.\");\n  }\n\n  availableHelper(name, versionRange) {\n    let minVersion;\n\n    try {\n      minVersion = helpers().minVersion(name);\n    } catch (err) {\n      if (err.code !== \"BABEL_HELPER_UNKNOWN\") throw err;\n      return false;\n    }\n\n    if (typeof versionRange !== \"string\") return true;\n    if (_semver().default.valid(versionRange)) versionRange = `^${versionRange}`;\n    return !_semver().default.intersects(`<${minVersion}`, versionRange) && !_semver().default.intersects(`>=8.0.0`, versionRange);\n  }\n\n  addHelper(name) {\n    const declar = this.declarations[name];\n    if (declar) return t().cloneNode(declar);\n    const generator = this.get(\"helperGenerator\");\n\n    if (generator) {\n      const res = generator(name);\n      if (res) return res;\n    }\n\n    const uid = this.declarations[name] = this.scope.generateUidIdentifier(name);\n    const dependencies = {};\n\n    for (const dep of helpers().getDependencies(name)) {\n      dependencies[dep] = this.addHelper(dep);\n    }\n\n    const {\n      nodes,\n      globals\n    } = helpers().get(name, dep => dependencies[dep], uid, Object.keys(this.scope.getAllBindings()));\n    globals.forEach(name => {\n      if (this.path.scope.hasBinding(name, true)) {\n        this.path.scope.rename(name);\n      }\n    });\n    nodes.forEach(node => {\n      node._compact = true;\n    });\n    this.path.unshiftContainer(\"body\", nodes);\n    this.path.get(\"body\").forEach(path => {\n      if (nodes.indexOf(path.node) === -1) return;\n      if (path.isVariableDeclaration()) this.scope.registerDeclaration(path);\n    });\n    return uid;\n  }\n\n  addTemplateObject() {\n    throw new Error(\"This function has been moved into the template literal transform itself.\");\n  }\n\n  buildCodeFrameError(node, msg, Error = SyntaxError) {\n    let loc = node && (node.loc || node._loc);\n    msg = `${this.opts.filename}: ${msg}`;\n\n    if (!loc && node) {\n      const state = {\n        loc: null\n      };\n      (0, _traverse().default)(node, errorVisitor, this.scope, state);\n      loc = state.loc;\n      let txt = \"This is an error on an internal node. Probably an internal error.\";\n      if (loc) txt += \" Location has been estimated.\";\n      msg += ` (${txt})`;\n    }\n\n    if (loc) {\n      const {\n        highlightCode = true\n      } = this.opts;\n      msg += \"\\n\" + (0, _codeFrame().codeFrameColumns)(this.code, {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column + 1\n        }\n      }, {\n        highlightCode\n      });\n    }\n\n    return new Error(msg);\n  }\n\n}\n\nexports.default = File;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nfunction helpers() {\n  const data = _interopRequireWildcard(require(\"@babel/helpers\"));\n\n  helpers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _generator() {\n  const data = _interopRequireDefault(require(\"@babel/generator\"));\n\n  _generator = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _template() {\n  const data = _interopRequireDefault(require(\"@babel/template\"));\n\n  _template = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nconst buildUmdWrapper = replacements => _template().default`\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  `(replacements);\n\nfunction buildGlobal(whitelist) {\n  const namespace = t().identifier(\"babelHelpers\");\n  const body = [];\n  const container = t().functionExpression(null, [t().identifier(\"global\")], t().blockStatement(body));\n  const tree = t().program([t().expressionStatement(t().callExpression(container, [t().conditionalExpression(t().binaryExpression(\"===\", t().unaryExpression(\"typeof\", t().identifier(\"global\")), t().stringLiteral(\"undefined\")), t().identifier(\"self\"), t().identifier(\"global\"))]))]);\n  body.push(t().variableDeclaration(\"var\", [t().variableDeclarator(namespace, t().assignmentExpression(\"=\", t().memberExpression(t().identifier(\"global\"), namespace), t().objectExpression([])))]));\n  buildHelpers(body, namespace, whitelist);\n  return tree;\n}\n\nfunction buildModule(whitelist) {\n  const body = [];\n  const refs = buildHelpers(body, null, whitelist);\n  body.unshift(t().exportNamedDeclaration(null, Object.keys(refs).map(name => {\n    return t().exportSpecifier(t().cloneNode(refs[name]), t().identifier(name));\n  })));\n  return t().program(body, [], \"module\");\n}\n\nfunction buildUmd(whitelist) {\n  const namespace = t().identifier(\"babelHelpers\");\n  const body = [];\n  body.push(t().variableDeclaration(\"var\", [t().variableDeclarator(namespace, t().identifier(\"global\"))]));\n  buildHelpers(body, namespace, whitelist);\n  return t().program([buildUmdWrapper({\n    FACTORY_PARAMETERS: t().identifier(\"global\"),\n    BROWSER_ARGUMENTS: t().assignmentExpression(\"=\", t().memberExpression(t().identifier(\"root\"), namespace), t().objectExpression([])),\n    COMMON_ARGUMENTS: t().identifier(\"exports\"),\n    AMD_ARGUMENTS: t().arrayExpression([t().stringLiteral(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: t().identifier(\"this\")\n  })]);\n}\n\nfunction buildVar(whitelist) {\n  const namespace = t().identifier(\"babelHelpers\");\n  const body = [];\n  body.push(t().variableDeclaration(\"var\", [t().variableDeclarator(namespace, t().objectExpression([]))]));\n  const tree = t().program(body);\n  buildHelpers(body, namespace, whitelist);\n  body.push(t().expressionStatement(namespace));\n  return tree;\n}\n\nfunction buildHelpers(body, namespace, whitelist) {\n  const getHelperReference = name => {\n    return namespace ? t().memberExpression(namespace, t().identifier(name)) : t().identifier(`_${name}`);\n  };\n\n  const refs = {};\n  helpers().list.forEach(function (name) {\n    if (whitelist && whitelist.indexOf(name) < 0) return;\n    const ref = refs[name] = getHelperReference(name);\n    const {\n      nodes\n    } = helpers().get(name, getHelperReference, ref);\n    body.push(...nodes);\n  });\n  return refs;\n}\n\nfunction _default(whitelist, outputType = \"global\") {\n  let tree;\n  const build = {\n    global: buildGlobal,\n    module: buildModule,\n    umd: buildUmd,\n    var: buildVar\n  }[outputType];\n\n  if (build) {\n    tree = build(whitelist);\n  } else {\n    throw new Error(`Unsupported output type ${outputType}`);\n  }\n\n  return (0, _generator().default)(tree).code;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"findPackageData\", {\n  enumerable: true,\n  get: function () {\n    return _package.findPackageData;\n  }\n});\nObject.defineProperty(exports, \"findConfigUpwards\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findConfigUpwards;\n  }\n});\nObject.defineProperty(exports, \"findRelativeConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRelativeConfig;\n  }\n});\nObject.defineProperty(exports, \"findRootConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.findRootConfig;\n  }\n});\nObject.defineProperty(exports, \"loadConfig\", {\n  enumerable: true,\n  get: function () {\n    return _configuration.loadConfig;\n  }\n});\nObject.defineProperty(exports, \"resolvePlugin\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.resolvePlugin;\n  }\n});\nObject.defineProperty(exports, \"resolvePreset\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.resolvePreset;\n  }\n});\nObject.defineProperty(exports, \"loadPlugin\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.loadPlugin;\n  }\n});\nObject.defineProperty(exports, \"loadPreset\", {\n  enumerable: true,\n  get: function () {\n    return _plugins.loadPreset;\n  }\n});\n\nvar _package = require(\"./package\");\n\nvar _configuration = require(\"./configuration\");\n\nvar _plugins = require(\"./plugins\");\n\n({});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findPackageData = findPackageData;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst PACKAGE_FILENAME = \"package.json\";\n\nfunction findPackageData(filepath) {\n  let pkg = null;\n  const directories = [];\n  let isPackage = true;\n\n  let dirname = _path().default.dirname(filepath);\n\n  while (!pkg && _path().default.basename(dirname) !== \"node_modules\") {\n    directories.push(dirname);\n    pkg = readConfigPackage(_path().default.join(dirname, PACKAGE_FILENAME));\n\n    const nextLoc = _path().default.dirname(dirname);\n\n    if (dirname === nextLoc) {\n      isPackage = false;\n      break;\n    }\n\n    dirname = nextLoc;\n  }\n\n  return {\n    filepath,\n    directories,\n    pkg,\n    isPackage\n  };\n}\n\nconst readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  let options;\n\n  try {\n    options = JSON.parse(content);\n  } catch (err) {\n    err.message = `${filepath}: Error while parsing JSON - ${err.message}`;\n    throw err;\n  }\n\n  if (typeof options !== \"object\") {\n    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);\n  }\n\n  if (Array.isArray(options)) {\n    throw new Error(`${filepath}: Expected config object but found array`);\n  }\n\n  return {\n    filepath,\n    dirname: _path().default.dirname(filepath),\n    options\n  };\n});","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeStaticFileCache = makeStaticFileCache;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"../caching\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction makeStaticFileCache(fn) {\n  return (0, _caching.makeStrongCache)((filepath, cache) => {\n    if (cache.invalidate(() => fileMtime(filepath)) === null) {\n      cache.forever();\n      return null;\n    }\n\n    return fn(filepath, _fs().default.readFileSync(filepath, \"utf8\"));\n  });\n}\n\nfunction fileMtime(filepath) {\n  try {\n    return +_fs().default.statSync(filepath).mtime;\n  } catch (e) {\n    if (e.code !== \"ENOENT\" && e.code !== \"ENOTDIR\") throw e;\n  }\n\n  return null;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeStrongCache = makeStrongCache;\nexports.makeWeakCache = makeWeakCache;\nexports.assertSimpleType = assertSimpleType;\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(new Map(), handler);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(new WeakMap(), handler);\n}\n\nfunction makeCachedFunction(callCache, handler) {\n  return function cachedFunction(arg, data) {\n    let cachedValue = callCache.get(arg);\n\n    if (cachedValue) {\n      for (const _ref of cachedValue) {\n        const {\n          value,\n          valid\n        } = _ref;\n        if (valid(data)) return value;\n      }\n    }\n\n    const cache = new CacheConfigurator(data);\n    const value = handler(arg, cache);\n    if (!cache.configured()) cache.forever();\n    cache.deactivate();\n\n    switch (cache.mode()) {\n      case \"forever\":\n        cachedValue = [{\n          value,\n          valid: () => true\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"invalidate\":\n        cachedValue = [{\n          value,\n          valid: cache.validator()\n        }];\n        callCache.set(arg, cachedValue);\n        break;\n\n      case \"valid\":\n        if (cachedValue) {\n          cachedValue.push({\n            value,\n            valid: cache.validator()\n          });\n        } else {\n          cachedValue = [{\n            value,\n            valid: cache.validator()\n          }];\n          callCache.set(arg, cachedValue);\n        }\n\n    }\n\n    return value;\n  };\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n\n    this._pairs.push([key, handler]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._invalidate = true;\n    this._configured = true;\n    const key = handler(this._data);\n\n    this._pairs.push([key, handler]);\n\n    return key;\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return data => pairs.every(([key, fn]) => key === fn(data));\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findConfigUpwards = findConfigUpwards;\nexports.findRelativeConfig = findRelativeConfig;\nexports.findRootConfig = findRootConfig;\nexports.loadConfig = loadConfig;\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _json() {\n  const data = _interopRequireDefault(require(\"json5\"));\n\n  _json = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _resolve() {\n  const data = _interopRequireDefault(require(\"resolve\"));\n\n  _resolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"../caching\");\n\nvar _configApi = _interopRequireDefault(require(\"../helpers/config-api\"));\n\nvar _utils = require(\"./utils\");\n\nvar _patternToRegex = _interopRequireDefault(require(\"../pattern-to-regex\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:config:loading:files:configuration\");\nconst BABEL_CONFIG_JS_FILENAME = \"babel.config.js\";\nconst BABELRC_FILENAME = \".babelrc\";\nconst BABELRC_JS_FILENAME = \".babelrc.js\";\nconst BABELIGNORE_FILENAME = \".babelignore\";\n\nfunction findConfigUpwards(rootDir) {\n  let dirname = rootDir;\n\n  while (true) {\n    if (_fs().default.existsSync(_path().default.join(dirname, BABEL_CONFIG_JS_FILENAME))) {\n      return dirname;\n    }\n\n    const nextDir = _path().default.dirname(dirname);\n\n    if (dirname === nextDir) break;\n    dirname = nextDir;\n  }\n\n  return null;\n}\n\nfunction findRelativeConfig(packageData, envName, caller) {\n  let config = null;\n  let ignore = null;\n\n  const dirname = _path().default.dirname(packageData.filepath);\n\n  for (const loc of packageData.directories) {\n    if (!config) {\n      config = [BABELRC_FILENAME, BABELRC_JS_FILENAME].reduce((previousConfig, name) => {\n        const filepath = _path().default.join(loc, name);\n\n        const config = readConfig(filepath, envName, caller);\n\n        if (config && previousConfig) {\n          throw new Error(`Multiple configuration files found. Please remove one:\\n` + ` - ${_path().default.basename(previousConfig.filepath)}\\n` + ` - ${name}\\n` + `from ${loc}`);\n        }\n\n        return config || previousConfig;\n      }, null);\n      const pkgConfig = packageData.pkg && packageData.pkg.dirname === loc ? packageToBabelConfig(packageData.pkg) : null;\n\n      if (pkgConfig) {\n        if (config) {\n          throw new Error(`Multiple configuration files found. Please remove one:\\n` + ` - ${_path().default.basename(pkgConfig.filepath)}#babel\\n` + ` - ${_path().default.basename(config.filepath)}\\n` + `from ${loc}`);\n        }\n\n        config = pkgConfig;\n      }\n\n      if (config) {\n        debug(\"Found configuration %o from %o.\", config.filepath, dirname);\n      }\n    }\n\n    if (!ignore) {\n      const ignoreLoc = _path().default.join(loc, BABELIGNORE_FILENAME);\n\n      ignore = readIgnoreConfig(ignoreLoc);\n\n      if (ignore) {\n        debug(\"Found ignore %o from %o.\", ignore.filepath, dirname);\n      }\n    }\n  }\n\n  return {\n    config,\n    ignore\n  };\n}\n\nfunction findRootConfig(dirname, envName, caller) {\n  const filepath = _path().default.resolve(dirname, BABEL_CONFIG_JS_FILENAME);\n\n  const conf = readConfig(filepath, envName, caller);\n\n  if (conf) {\n    debug(\"Found root config %o in $o.\", BABEL_CONFIG_JS_FILENAME, dirname);\n  }\n\n  return conf;\n}\n\nfunction loadConfig(name, dirname, envName, caller) {\n  const filepath = _resolve().default.sync(name, {\n    basedir: dirname\n  });\n\n  const conf = readConfig(filepath, envName, caller);\n\n  if (!conf) {\n    throw new Error(`Config file ${filepath} contains no configuration data`);\n  }\n\n  debug(\"Loaded config %o from $o.\", name, dirname);\n  return conf;\n}\n\nfunction readConfig(filepath, envName, caller) {\n  return _path().default.extname(filepath) === \".js\" ? readConfigJS(filepath, {\n    envName,\n    caller\n  }) : readConfigJSON5(filepath);\n}\n\nconst LOADING_CONFIGS = new Set();\nconst readConfigJS = (0, _caching.makeStrongCache)((filepath, cache) => {\n  if (!_fs().default.existsSync(filepath)) {\n    cache.forever();\n    return null;\n  }\n\n  if (LOADING_CONFIGS.has(filepath)) {\n    cache.never();\n    debug(\"Auto-ignoring usage of config %o.\", filepath);\n    return {\n      filepath,\n      dirname: _path().default.dirname(filepath),\n      options: {}\n    };\n  }\n\n  let options;\n\n  try {\n    LOADING_CONFIGS.add(filepath);\n\n    const configModule = require(filepath);\n\n    options = configModule && configModule.__esModule ? configModule.default || undefined : configModule;\n  } catch (err) {\n    err.message = `${filepath}: Error while loading config - ${err.message}`;\n    throw err;\n  } finally {\n    LOADING_CONFIGS.delete(filepath);\n  }\n\n  if (typeof options === \"function\") {\n    options = options((0, _configApi.default)(cache));\n    if (!cache.configured()) throwConfigError();\n  }\n\n  if (!options || typeof options !== \"object\" || Array.isArray(options)) {\n    throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);\n  }\n\n  if (typeof options.then === \"function\") {\n    throw new Error(`You appear to be using an async configuration, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously return your config.`);\n  }\n\n  return {\n    filepath,\n    dirname: _path().default.dirname(filepath),\n    options\n  };\n});\nconst packageToBabelConfig = (0, _caching.makeWeakCache)(file => {\n  const babel = file.options[\"babel\"];\n  if (typeof babel === \"undefined\") return null;\n\n  if (typeof babel !== \"object\" || Array.isArray(babel) || babel === null) {\n    throw new Error(`${file.filepath}: .babel property must be an object`);\n  }\n\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: babel\n  };\n});\nconst readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  let options;\n\n  try {\n    options = _json().default.parse(content);\n  } catch (err) {\n    err.message = `${filepath}: Error while parsing config - ${err.message}`;\n    throw err;\n  }\n\n  if (!options) throw new Error(`${filepath}: No config detected`);\n\n  if (typeof options !== \"object\") {\n    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);\n  }\n\n  if (Array.isArray(options)) {\n    throw new Error(`${filepath}: Expected config object but found array`);\n  }\n\n  return {\n    filepath,\n    dirname: _path().default.dirname(filepath),\n    options\n  };\n});\nconst readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {\n  const ignoreDir = _path().default.dirname(filepath);\n\n  const ignorePatterns = content.split(\"\\n\").map(line => line.replace(/#(.*?)$/, \"\").trim()).filter(line => !!line);\n\n  for (const pattern of ignorePatterns) {\n    if (pattern[0] === \"!\") {\n      throw new Error(`Negation of file paths is not supported.`);\n    }\n  }\n\n  return {\n    filepath,\n    dirname: _path().default.dirname(filepath),\n    ignore: ignorePatterns.map(pattern => (0, _patternToRegex.default)(pattern, ignoreDir))\n  };\n});\n\nfunction throwConfigError() {\n  throw new Error(`\\\nCaching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don't call this function again.\n  api.cache(true);\n\n  // Don't cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === \"production\");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === \"production\");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};`);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = makeAPI;\n\nfunction _semver() {\n  const data = _interopRequireDefault(require(\"semver\"));\n\n  _semver = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ = require(\"../../\");\n\nvar _caching = require(\"../caching\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction makeAPI(cache) {\n  const env = value => cache.using(data => {\n    if (typeof value === \"undefined\") return data.envName;\n\n    if (typeof value === \"function\") {\n      return (0, _caching.assertSimpleType)(value(data.envName));\n    }\n\n    if (!Array.isArray(value)) value = [value];\n    return value.some(entry => {\n      if (typeof entry !== \"string\") {\n        throw new Error(\"Unexpected non-string value\");\n      }\n\n      return entry === data.envName;\n    });\n  });\n\n  const caller = cb => cache.using(data => (0, _caching.assertSimpleType)(cb(data.caller)));\n\n  return {\n    version: _.version,\n    cache: cache.simple(),\n    env,\n    async: () => false,\n    caller,\n    assertVersion,\n    tokTypes: undefined\n  };\n}\n\nfunction assertVersion(range) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n\n    range = `^${range}.0.0-0`;\n  }\n\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  if (_semver().default.satisfies(_.version, range)) return;\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n\n  const err = new Error(`Requires Babel \"${range}\", but was loaded with \"${_.version}\". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` + `to see what is calling Babel.`);\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: _.version,\n    range\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = pathToPattern;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _escapeRegExp() {\n  const data = _interopRequireDefault(require(\"lodash/escapeRegExp\"));\n\n  _escapeRegExp = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst sep = `\\\\${_path().default.sep}`;\nconst endSep = `(?:${sep}|$)`;\nconst substitution = `[^${sep}]+`;\nconst starPat = `(?:${substitution}${sep})`;\nconst starPatLast = `(?:${substitution}${endSep})`;\nconst starStarPat = `${starPat}*?`;\nconst starStarPatLast = `${starPat}*?${starPatLast}?`;\n\nfunction pathToPattern(pattern, dirname) {\n  const parts = _path().default.resolve(dirname, pattern).split(_path().default.sep);\n\n  return new RegExp([\"^\", ...parts.map((part, i) => {\n    const last = i === parts.length - 1;\n    if (part === \"**\") return last ? starStarPatLast : starStarPat;\n    if (part === \"*\") return last ? starPatLast : starPat;\n\n    if (part.indexOf(\"*.\") === 0) {\n      return substitution + (0, _escapeRegExp().default)(part.slice(1)) + (last ? endSep : sep);\n    }\n\n    return (0, _escapeRegExp().default)(part) + (last ? endSep : sep);\n  })].join(\"\"));\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolvePlugin = resolvePlugin;\nexports.resolvePreset = resolvePreset;\nexports.loadPlugin = loadPlugin;\nexports.loadPreset = loadPreset;\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _resolve() {\n  const data = _interopRequireDefault(require(\"resolve\"));\n\n  _resolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:config:loading:files:plugins\");\nconst EXACT_RE = /^module:/;\nconst BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-plugin-)/;\nconst BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-preset-)/;\nconst BABEL_PLUGIN_ORG_RE = /^(@babel\\/)(?!plugin-|[^/]+\\/)/;\nconst BABEL_PRESET_ORG_RE = /^(@babel\\/)(?!preset-|[^/]+\\/)/;\nconst OTHER_PLUGIN_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-plugin(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_PRESET_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-preset(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;\n\nfunction resolvePlugin(name, dirname) {\n  return resolveStandardizedName(\"plugin\", name, dirname);\n}\n\nfunction resolvePreset(name, dirname) {\n  return resolveStandardizedName(\"preset\", name, dirname);\n}\n\nfunction loadPlugin(name, dirname) {\n  const filepath = resolvePlugin(name, dirname);\n\n  if (!filepath) {\n    throw new Error(`Plugin ${name} not found relative to ${dirname}`);\n  }\n\n  const value = requireModule(\"plugin\", filepath);\n  debug(\"Loaded plugin %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction loadPreset(name, dirname) {\n  const filepath = resolvePreset(name, dirname);\n\n  if (!filepath) {\n    throw new Error(`Preset ${name} not found relative to ${dirname}`);\n  }\n\n  const value = requireModule(\"preset\", filepath);\n  debug(\"Loaded preset %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction standardizeName(type, name) {\n  if (_path().default.isAbsolute(name)) return name;\n  const isPreset = type === \"preset\";\n  return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, \"\");\n}\n\nfunction resolveStandardizedName(type, name, dirname = process.cwd()) {\n  const standardizedName = standardizeName(type, name);\n\n  try {\n    return _resolve().default.sync(standardizedName, {\n      basedir: dirname\n    });\n  } catch (e) {\n    if (e.code !== \"MODULE_NOT_FOUND\") throw e;\n\n    if (standardizedName !== name) {\n      let resolvedOriginal = false;\n\n      try {\n        _resolve().default.sync(name, {\n          basedir: dirname\n        });\n\n        resolvedOriginal = true;\n      } catch (e2) {}\n\n      if (resolvedOriginal) {\n        e.message += `\\n- If you want to resolve \"${name}\", use \"module:${name}\"`;\n      }\n    }\n\n    let resolvedBabel = false;\n\n    try {\n      _resolve().default.sync(standardizeName(type, \"@babel/\" + name), {\n        basedir: dirname\n      });\n\n      resolvedBabel = true;\n    } catch (e2) {}\n\n    if (resolvedBabel) {\n      e.message += `\\n- Did you mean \"@babel/${name}\"?`;\n    }\n\n    let resolvedOppositeType = false;\n    const oppositeType = type === \"preset\" ? \"plugin\" : \"preset\";\n\n    try {\n      _resolve().default.sync(standardizeName(oppositeType, name), {\n        basedir: dirname\n      });\n\n      resolvedOppositeType = true;\n    } catch (e2) {}\n\n    if (resolvedOppositeType) {\n      e.message += `\\n- Did you accidentally pass a ${oppositeType} as a ${type}?`;\n    }\n\n    throw e;\n  }\n}\n\nconst LOADING_MODULES = new Set();\n\nfunction requireModule(type, name) {\n  if (LOADING_MODULES.has(name)) {\n    throw new Error(`Reentrant ${type} detected trying to load \"${name}\". This module is not ignored ` + \"and is trying to load itself while compiling itself, leading to a dependency cycle. \" + 'We recommend adding it to your \"ignore\" list in your babelrc, or to a .babelignore.');\n  }\n\n  try {\n    LOADING_MODULES.add(name);\n    return require(name);\n  } finally {\n    LOADING_MODULES.delete(name);\n  }\n}","module.exports = {\n  \"name\": \"@babel/core\",\n  \"version\": \"7.4.5\",\n  \"description\": \"Babel compiler core.\",\n  \"main\": \"lib/index.js\",\n  \"author\": \"Sebastian McKenzie <sebmck@gmail.com>\",\n  \"homepage\": \"https://babeljs.io/\",\n  \"license\": \"MIT\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"repository\": \"https://github.com/babel/babel/tree/master/packages/babel-core\",\n  \"keywords\": [\n    \"6to5\",\n    \"babel\",\n    \"classes\",\n    \"const\",\n    \"es6\",\n    \"harmony\",\n    \"let\",\n    \"modules\",\n    \"transpile\",\n    \"transpiler\",\n    \"var\",\n    \"babel-core\",\n    \"compiler\"\n  ],\n  \"engines\": {\n    \"node\": \">=6.9.0\"\n  },\n  \"browser\": {\n    \"./lib/config/files/index.js\": \"./lib/config/files/index-browser.js\",\n    \"./lib/transform-file.js\": \"./lib/transform-file-browser.js\"\n  },\n  \"dependencies\": {\n    \"@babel/code-frame\": \"^7.0.0\",\n    \"@babel/generator\": \"^7.4.4\",\n    \"@babel/helpers\": \"^7.4.4\",\n    \"@babel/parser\": \"^7.4.5\",\n    \"@babel/template\": \"^7.4.4\",\n    \"@babel/traverse\": \"^7.4.5\",\n    \"@babel/types\": \"^7.4.4\",\n    \"convert-source-map\": \"^1.1.0\",\n    \"debug\": \"^4.1.0\",\n    \"json5\": \"^2.1.0\",\n    \"lodash\": \"^4.17.11\",\n    \"resolve\": \"^1.3.2\",\n    \"semver\": \"^5.4.1\",\n    \"source-map\": \"^0.5.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/helper-transform-fixture-test-runner\": \"^7.4.4\",\n    \"@babel/register\": \"^7.4.4\"\n  },\n  \"gitHead\": \"33ab4f166117e2380de3955a0842985f578b01b8\"\n}\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEnv = getEnv;\n\nfunction getEnv(defaultValue = \"development\") {\n  return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createItemFromDescriptor = createItemFromDescriptor;\nexports.createConfigItem = createConfigItem;\nexports.getItemDescriptor = getItemDescriptor;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction createItemFromDescriptor(desc) {\n  return new ConfigItem(desc);\n}\n\nfunction createConfigItem(value, {\n  dirname = \".\",\n  type\n} = {}) {\n  const descriptor = (0, _configDescriptors.createDescriptor)(value, _path().default.resolve(dirname), {\n    type,\n    alias: \"programmatic item\"\n  });\n  return createItemFromDescriptor(descriptor);\n}\n\nfunction getItemDescriptor(item) {\n  if (item instanceof ConfigItem) {\n    return item._descriptor;\n  }\n\n  return undefined;\n}\n\nclass ConfigItem {\n  constructor(descriptor) {\n    this._descriptor = descriptor;\n    Object.defineProperty(this, \"_descriptor\", {\n      enumerable: false\n    });\n    this.value = this._descriptor.value;\n    this.options = this._descriptor.options;\n    this.dirname = this._descriptor.dirname;\n    this.name = this._descriptor.name;\n    this.file = this._descriptor.file ? {\n      request: this._descriptor.file.request,\n      resolved: this._descriptor.file.resolved\n    } : undefined;\n    Object.freeze(this);\n  }\n\n}\n\nObject.freeze(ConfigItem.prototype);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCachedDescriptors = createCachedDescriptors;\nexports.createUncachedDescriptors = createUncachedDescriptors;\nexports.createDescriptor = createDescriptor;\n\nvar _files = require(\"./files\");\n\nvar _item = require(\"./item\");\n\nvar _caching = require(\"./caching\");\n\nfunction isEqualDescriptor(a, b) {\n  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);\n}\n\nfunction createCachedDescriptors(dirname, options, alias) {\n  const {\n    plugins,\n    presets,\n    passPerPreset\n  } = options;\n  return {\n    options,\n    plugins: plugins ? () => createCachedPluginDescriptors(plugins, dirname)(alias) : () => [],\n    presets: presets ? () => createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset) : () => []\n  };\n}\n\nfunction createUncachedDescriptors(dirname, options, alias) {\n  let plugins;\n  let presets;\n  return {\n    options,\n    plugins: () => {\n      if (!plugins) {\n        plugins = createPluginDescriptors(options.plugins || [], dirname, alias);\n      }\n\n      return plugins;\n    },\n    presets: () => {\n      if (!presets) {\n        presets = createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);\n      }\n\n      return presets;\n    }\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = (0, _caching.makeWeakCache)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCache)(alias => (0, _caching.makeStrongCache)(passPerPreset => createPresetDescriptors(items, dirname, alias, passPerPreset).map(desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc))));\n});\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = (0, _caching.makeWeakCache)((items, cache) => {\n  const dirname = cache.using(dir => dir);\n  return (0, _caching.makeStrongCache)(alias => createPluginDescriptors(items, dirname, alias).map(desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc)));\n});\nconst DEFAULT_OPTIONS = {};\n\nfunction loadCachedDescriptor(cache, desc) {\n  const {\n    value,\n    options = DEFAULT_OPTIONS\n  } = desc;\n  if (options === false) return desc;\n  let cacheByOptions = cache.get(value);\n\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility => isEqualDescriptor(possibility, desc));\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction createPresetDescriptors(items, dirname, alias, passPerPreset) {\n  return createDescriptors(\"preset\", items, dirname, alias, passPerPreset);\n}\n\nfunction createPluginDescriptors(items, dirname, alias) {\n  return createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction createDescriptors(type, items, dirname, alias, ownPass) {\n  const descriptors = items.map((item, index) => createDescriptor(item, dirname, {\n    type,\n    alias: `${alias}$${index}`,\n    ownPass: !!ownPass\n  }));\n  assertNoDuplicates(descriptors);\n  return descriptors;\n}\n\nfunction createDescriptor(pair, dirname, {\n  type,\n  alias,\n  ownPass\n}) {\n  const desc = (0, _item.getItemDescriptor)(pair);\n\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  let value = pair;\n\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\"To resolve a string-based item, the type of item must be given\");\n    }\n\n    const resolver = type === \"plugin\" ? _files.loadPlugin : _files.loadPreset;\n    const request = value;\n    ({\n      filepath,\n      value\n    } = resolver(value, dirname));\n    file = {\n      request,\n      resolved: filepath\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(`Unsupported format: ${typeof value}. Expected an object or a function.`);\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file\n  };\n}\n\nfunction assertNoDuplicates(items) {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n    let nameMap = map.get(item.value);\n\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n\n    if (nameMap.has(item.name)) {\n      throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`].join(\"\\n\"));\n    }\n\n    nameMap.add(item.name);\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadOptions = loadOptions;\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return _full.default;\n  }\n});\nObject.defineProperty(exports, \"loadPartialConfig\", {\n  enumerable: true,\n  get: function () {\n    return _partial.loadPartialConfig;\n  }\n});\n\nvar _full = _interopRequireDefault(require(\"./full\"));\n\nvar _partial = require(\"./partial\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction loadOptions(opts) {\n  const config = (0, _full.default)(opts);\n  return config ? config.options : null;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadFullConfig;\n\nvar _util = require(\"./util\");\n\nvar context = _interopRequireWildcard(require(\"../index\"));\n\nvar _plugin = _interopRequireDefault(require(\"./plugin\"));\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nfunction _traverse() {\n  const data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = _interopRequireDefault(require(\"./helpers/config-api\"));\n\nvar _partial = _interopRequireDefault(require(\"./partial\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction loadFullConfig(inputOpts) {\n  const result = (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context\n  } = result;\n  const optionDefaults = {};\n  const passes = [[]];\n\n  try {\n    const {\n      plugins,\n      presets\n    } = options;\n\n    if (!plugins || !presets) {\n      throw new Error(\"Assertion failure - plugins and presets exist\");\n    }\n\n    const ignored = function recurseDescriptors(config, pass) {\n      const plugins = config.plugins.reduce((acc, descriptor) => {\n        if (descriptor.options !== false) {\n          acc.push(loadPluginDescriptor(descriptor, context));\n        }\n\n        return acc;\n      }, []);\n      const presets = config.presets.reduce((acc, descriptor) => {\n        if (descriptor.options !== false) {\n          acc.push({\n            preset: loadPresetDescriptor(descriptor, context),\n            pass: descriptor.ownPass ? [] : pass\n          });\n        }\n\n        return acc;\n      }, []);\n\n      if (presets.length > 0) {\n        passes.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pass));\n\n        for (const _ref of presets) {\n          const {\n            preset,\n            pass\n          } = _ref;\n          if (!preset) return true;\n          const ignored = recurseDescriptors({\n            plugins: preset.plugins,\n            presets: preset.presets\n          }, pass);\n          if (ignored) return true;\n          preset.options.forEach(opts => {\n            (0, _util.mergeOptions)(optionDefaults, opts);\n          });\n        }\n      }\n\n      if (plugins.length > 0) {\n        pass.unshift(...plugins);\n      }\n    }({\n      plugins: plugins.map(item => {\n        const desc = (0, _item.getItemDescriptor)(item);\n\n        if (!desc) {\n          throw new Error(\"Assertion failure - must be config item\");\n        }\n\n        return desc;\n      }),\n      presets: presets.map(item => {\n        const desc = (0, _item.getItemDescriptor)(item);\n\n        if (!desc) {\n          throw new Error(\"Assertion failure - must be config item\");\n        }\n\n        return desc;\n      })\n    }, passes[0]);\n\n    if (ignored) return null;\n  } catch (e) {\n    if (!/^\\[BABEL\\]/.test(e.message)) {\n      e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n    }\n\n    throw e;\n  }\n\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes\n  };\n}\n\nconst loadDescriptor = (0, _caching.makeWeakCache)(({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) => {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const api = Object.assign({}, context, (0, _configApi.default)(cache));\n\n    try {\n      item = value(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if (typeof item.then === \"function\") {\n    throw new Error(`You appear to be using an async plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias\n  };\n});\n\nfunction loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return instantiatePlugin(loadDescriptor(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) => {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = cache.invalidate(data => loadPluginDescriptor(inheritsDescriptor, data));\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n  }\n\n  return new _plugin.default(plugin, options, alias);\n});\n\nconst loadPresetDescriptor = (descriptor, context) => {\n  return (0, _configChain.buildPresetChain)(instantiatePreset(loadDescriptor(descriptor, context)), context);\n};\n\nconst instantiatePreset = (0, _caching.makeWeakCache)(({\n  value,\n  dirname,\n  alias\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeOptions = mergeOptions;\n\nfunction mergeOptions(target, source) {\n  for (const k of Object.keys(source)) {\n    if (k === \"parserOpts\" && source.parserOpts) {\n      const parserOpts = source.parserOpts;\n      const targetObj = target.parserOpts = target.parserOpts || {};\n      mergeDefaultFields(targetObj, parserOpts);\n    } else if (k === \"generatorOpts\" && source.generatorOpts) {\n      const generatorOpts = source.generatorOpts;\n      const targetObj = target.generatorOpts = target.generatorOpts || {};\n      mergeDefaultFields(targetObj, generatorOpts);\n    } else {\n      const val = source[k];\n      if (val !== undefined) target[k] = val;\n    }\n  }\n}\n\nfunction mergeDefaultFields(target, source) {\n  for (const k of Object.keys(source)) {\n    const val = source[k];\n    if (val !== undefined) target[k] = val;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Plugin {\n  constructor(plugin, options, key) {\n    this.key = plugin.name || key;\n    this.manipulateOptions = plugin.manipulateOptions;\n    this.post = plugin.post;\n    this.pre = plugin.pre;\n    this.visitor = plugin.visitor || {};\n    this.parserOverride = plugin.parserOverride;\n    this.generatorOverride = plugin.generatorOverride;\n    this.options = options;\n  }\n\n}\n\nexports.default = Plugin;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = _interopRequireDefault(require(\"./pattern-to-regex\"));\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:config:config-chain\");\n\nfunction buildPresetChain(arg, context) {\n  const chain = buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o))\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  init: arg => arg,\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName)\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCache)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCache)(preset => (0, _caching.makeStrongCache)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCache)(preset => (0, _caching.makeStrongCache)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCache)(preset => (0, _caching.makeStrongCache)(index => (0, _caching.makeStrongCache)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildRootChain(opts, context) {\n  const programmaticChain = loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context);\n  if (!programmaticChain) return null;\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = loadFileChain(validatedFile, context);\n    if (!result) return null;\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  const pkgData = typeof context.filename === \"string\" ? (0, _files.findPackageData)(context.filename) : null;\n  let ignoreFile, babelrcFile;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n    ({\n      ignore: ignoreFile,\n      config: babelrcFile\n    } = (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n    if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n      return null;\n    }\n\n    if (babelrcFile) {\n      const result = loadFileChain(validateBabelrcFile(babelrcFile), context);\n      if (!result) return null;\n      mergeChain(fileChain, result);\n    }\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCache)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCache)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCache)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName)\n});\nconst loadFileChain = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName)\n});\nconst loadFileDescriptors = (0, _caching.makeWeakCache)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCache)(file => (0, _caching.makeStrongCache)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCache)(file => (0, _caching.makeStrongCache)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCache)(file => (0, _caching.makeStrongCache)(index => (0, _caching.makeStrongCache)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv\n}) {\n  return (input, context, files = new Set()) => {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push(rootOpts);\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push(envOpts);\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push(overrideOps);\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push(overrideEnvOpts);\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(({\n      options: {\n        ignore,\n        only\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n\n    const chain = emptyChain();\n\n    for (const op of flattenedConfigs) {\n      if (!mergeExtendsChain(chain, op.options, dirname, context, files)) {\n        return null;\n      }\n\n      mergeChainOpts(chain, op);\n    }\n\n    return chain;\n  };\n}\n\nfunction mergeExtendsChain(chain, opts, dirname, context, files) {\n  if (opts.extends === undefined) return true;\n  const file = (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = loadFileChain(validateExtendFile(file), context, files);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  return target;\n}\n\nfunction mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...plugins());\n  target.presets.push(...presets());\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: []\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (options.hasOwnProperty(\"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    debug(\"Ignored %o because it matched one of %O from %o\", context.filename, ignore, dirname);\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    debug(\"Ignored %o because it failed to match one of %O from %o\", context.filename, only, dirname);\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validate = validate;\n\nvar _plugin = _interopRequireDefault(require(\"../plugin\"));\n\nvar _removed = _interopRequireDefault(require(\"./removed\"));\n\nvar _optionAssertions = require(\"./option-assertions\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst ROOT_VALIDATORS = {\n  cwd: _optionAssertions.assertString,\n  root: _optionAssertions.assertString,\n  rootMode: _optionAssertions.assertRootMode,\n  configFile: _optionAssertions.assertConfigFileSearch,\n  caller: _optionAssertions.assertCallerMetadata,\n  filename: _optionAssertions.assertString,\n  filenameRelative: _optionAssertions.assertString,\n  code: _optionAssertions.assertBoolean,\n  ast: _optionAssertions.assertBoolean,\n  envName: _optionAssertions.assertString\n};\nconst BABELRC_VALIDATORS = {\n  babelrc: _optionAssertions.assertBoolean,\n  babelrcRoots: _optionAssertions.assertBabelrcSearch\n};\nconst NONPRESET_VALIDATORS = {\n  extends: _optionAssertions.assertString,\n  ignore: _optionAssertions.assertIgnoreList,\n  only: _optionAssertions.assertIgnoreList\n};\nconst COMMON_VALIDATORS = {\n  inputSourceMap: _optionAssertions.assertInputSourceMap,\n  presets: _optionAssertions.assertPluginList,\n  plugins: _optionAssertions.assertPluginList,\n  passPerPreset: _optionAssertions.assertBoolean,\n  env: assertEnvSet,\n  overrides: assertOverridesList,\n  test: _optionAssertions.assertConfigApplicableTest,\n  include: _optionAssertions.assertConfigApplicableTest,\n  exclude: _optionAssertions.assertConfigApplicableTest,\n  retainLines: _optionAssertions.assertBoolean,\n  comments: _optionAssertions.assertBoolean,\n  shouldPrintComment: _optionAssertions.assertFunction,\n  compact: _optionAssertions.assertCompact,\n  minified: _optionAssertions.assertBoolean,\n  auxiliaryCommentBefore: _optionAssertions.assertString,\n  auxiliaryCommentAfter: _optionAssertions.assertString,\n  sourceType: _optionAssertions.assertSourceType,\n  wrapPluginVisitorMethod: _optionAssertions.assertFunction,\n  highlightCode: _optionAssertions.assertBoolean,\n  sourceMaps: _optionAssertions.assertSourceMaps,\n  sourceMap: _optionAssertions.assertSourceMaps,\n  sourceFileName: _optionAssertions.assertString,\n  sourceRoot: _optionAssertions.assertString,\n  getModuleId: _optionAssertions.assertFunction,\n  moduleRoot: _optionAssertions.assertString,\n  moduleIds: _optionAssertions.assertBoolean,\n  moduleId: _optionAssertions.assertString,\n  parserOpts: _optionAssertions.assertObject,\n  generatorOpts: _optionAssertions.assertObject\n};\n\nfunction getSource(loc) {\n  return loc.type === \"root\" ? loc.source : getSource(loc.parent);\n}\n\nfunction validate(type, opts) {\n  return validateNested({\n    type: \"root\",\n    source: type\n  }, opts);\n}\n\nfunction validateNested(loc, opts) {\n  const type = getSource(loc);\n  assertNoDuplicateSourcemap(opts);\n  Object.keys(opts).forEach(key => {\n    const optLoc = {\n      type: \"option\",\n      name: key,\n      parent: loc\n    };\n\n    if (type === \"preset\" && NONPRESET_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);\n    }\n\n    if (type !== \"arguments\" && ROOT_VALIDATORS[key]) {\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);\n    }\n\n    if (type !== \"arguments\" && type !== \"configfile\" && BABELRC_VALIDATORS[key]) {\n      if (type === \"babelrcfile\" || type === \"extendsfile\") {\n        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);\n      }\n\n      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);\n    }\n\n    const validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;\n    validator(optLoc, opts[key]);\n  });\n  return opts;\n}\n\nfunction throwUnknownError(loc) {\n  const key = loc.name;\n\n  if (_removed.default[key]) {\n    const {\n      message,\n      version = 5\n    } = _removed.default[key];\n    throw new ReferenceError(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);\n  } else {\n    const unknownOptErr = `Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`;\n    throw new ReferenceError(unknownOptErr);\n  }\n}\n\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction assertNoDuplicateSourcemap(opts) {\n  if (has(opts, \"sourceMap\") && has(opts, \"sourceMaps\")) {\n    throw new Error(\".sourceMap is an alias for .sourceMaps, cannot use both\");\n  }\n}\n\nfunction assertEnvSet(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);\n  }\n\n  const parent = loc.parent;\n  const obj = (0, _optionAssertions.assertObject)(loc, value);\n\n  if (obj) {\n    for (const envName of Object.keys(obj)) {\n      const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);\n      if (!env) continue;\n      const envLoc = {\n        type: \"env\",\n        name: envName,\n        parent\n      };\n      validateNested(envLoc, env);\n    }\n  }\n\n  return obj;\n}\n\nfunction assertOverridesList(loc, value) {\n  if (loc.parent.type === \"env\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);\n  }\n\n  if (loc.parent.type === \"overrides\") {\n    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);\n  }\n\n  const parent = loc.parent;\n  const arr = (0, _optionAssertions.assertArray)(loc, value);\n\n  if (arr) {\n    for (const [index, item] of arr.entries()) {\n      const objLoc = (0, _optionAssertions.access)(loc, index);\n      const env = (0, _optionAssertions.assertObject)(objLoc, item);\n      if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);\n      const overridesLoc = {\n        type: \"overrides\",\n        index,\n        parent\n      };\n      validateNested(overridesLoc, env);\n    }\n  }\n\n  return arr;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = {\n  auxiliaryComment: {\n    message: \"Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`\"\n  },\n  blacklist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  breakConfig: {\n    message: \"This is not a necessary option in Babel 6\"\n  },\n  experimental: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  externalHelpers: {\n    message: \"Use the `external-helpers` plugin instead. \" + \"Check out http://babeljs.io/docs/plugins/external-helpers/\"\n  },\n  extra: {\n    message: \"\"\n  },\n  jsxPragma: {\n    message: \"use the `pragma` option in the `react-jsx` plugin. \" + \"Check out http://babeljs.io/docs/plugins/transform-react-jsx/\"\n  },\n  loose: {\n    message: \"Specify the `loose` option for the relevant plugin you are using \" + \"or use a preset that sets the option.\"\n  },\n  metadataUsedHelpers: {\n    message: \"Not required anymore as this is enabled by default\"\n  },\n  modules: {\n    message: \"Use the corresponding module transform plugin in the `plugins` option. \" + \"Check out http://babeljs.io/docs/plugins/#modules\"\n  },\n  nonStandard: {\n    message: \"Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. \" + \"Also check out the react preset http://babeljs.io/docs/plugins/preset-react/\"\n  },\n  optional: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  sourceMapName: {\n    message: \"The `sourceMapName` option has been removed because it makes more sense for the \" + \"tooling that calls Babel to assign `map.file` themselves.\"\n  },\n  stage: {\n    message: \"Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets\"\n  },\n  whitelist: {\n    message: \"Put the specific transforms you want in the `plugins` option\"\n  },\n  resolveModuleSource: {\n    version: 6,\n    message: \"Use `babel-plugin-module-resolver@3`'s 'resolvePath' options\"\n  },\n  metadata: {\n    version: 6,\n    message: \"Generated plugin metadata is always included in the output result\"\n  },\n  sourceMapTarget: {\n    version: 6,\n    message: \"The `sourceMapTarget` option has been removed because it makes more sense for the tooling \" + \"that calls Babel to assign `map.file` themselves.\"\n  }\n};\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj[\"name\"] !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Funtion/RegExp values, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n\n    if (value.length === 3) {\n      const name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n\n  return value;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePluginObject = validatePluginObject;\n\nvar _optionAssertions = require(\"./option-assertions\");\n\nconst VALIDATORS = {\n  name: _optionAssertions.assertString,\n  manipulateOptions: _optionAssertions.assertFunction,\n  pre: _optionAssertions.assertFunction,\n  post: _optionAssertions.assertFunction,\n  inherits: _optionAssertions.assertFunction,\n  visitor: assertVisitorMap,\n  parserOverride: _optionAssertions.assertFunction,\n  generatorOverride: _optionAssertions.assertFunction\n};\n\nfunction assertVisitorMap(key, value) {\n  const obj = (0, _optionAssertions.assertObject)(key, value);\n\n  if (obj) {\n    Object.keys(obj).forEach(prop => assertVisitorHandler(prop, obj[prop]));\n\n    if (obj.enter || obj.exit) {\n      throw new Error(`.${key} cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.`);\n    }\n  }\n\n  return obj;\n}\n\nfunction assertVisitorHandler(key, value) {\n  if (value && typeof value === \"object\") {\n    Object.keys(value).forEach(handler => {\n      if (handler !== \"enter\" && handler !== \"exit\") {\n        throw new Error(`.visitor[\"${key}\"] may only have .enter and/or .exit handlers.`);\n      }\n    });\n  } else if (typeof value !== \"function\") {\n    throw new Error(`.visitor[\"${key}\"] must be a function`);\n  }\n\n  return value;\n}\n\nfunction validatePluginObject(obj) {\n  Object.keys(obj).forEach(key => {\n    const validator = VALIDATORS[key];\n    if (validator) validator(key, obj[key]);else throw new Error(`.${key} is not a valid Plugin property`);\n  });\n  return obj;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadPrivatePartialConfig;\nexports.loadPartialConfig = loadPartialConfig;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _plugin = _interopRequireDefault(require(\"./plugin\"));\n\nvar _util = require(\"./util\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _environment = require(\"./helpers/environment\");\n\nvar _options = require(\"./validation/options\");\n\nvar _files = require(\"./files\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction resolveRootMode(rootDir, rootMode) {\n  switch (rootMode) {\n    case \"root\":\n      return rootDir;\n\n    case \"upward-optional\":\n      {\n        const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);\n        return upwardRootDir === null ? rootDir : upwardRootDir;\n      }\n\n    case \"upward\":\n      {\n        const upwardRootDir = (0, _files.findConfigUpwards)(rootDir);\n        if (upwardRootDir !== null) return upwardRootDir;\n        throw Object.assign(new Error(`Babel was run with rootMode:\"upward\" but a root could not ` + `be found when searching upward from \"${rootDir}\"`), {\n          code: \"BABEL_ROOT_NOT_FOUND\",\n          dirname: rootDir\n        });\n      }\n\n    default:\n      throw new Error(`Assertion failure - unknown rootMode value`);\n  }\n}\n\nfunction loadPrivatePartialConfig(inputOpts) {\n  if (inputOpts != null && (typeof inputOpts !== \"object\" || Array.isArray(inputOpts))) {\n    throw new Error(\"Babel options must be an object, null, or undefined\");\n  }\n\n  const args = inputOpts ? (0, _options.validate)(\"arguments\", inputOpts) : {};\n  const {\n    envName = (0, _environment.getEnv)(),\n    cwd = \".\",\n    root: rootDir = \".\",\n    rootMode = \"root\",\n    caller\n  } = args;\n\n  const absoluteCwd = _path().default.resolve(cwd);\n\n  const absoluteRootDir = resolveRootMode(_path().default.resolve(absoluteCwd, rootDir), rootMode);\n  const context = {\n    filename: typeof args.filename === \"string\" ? _path().default.resolve(cwd, args.filename) : undefined,\n    cwd: absoluteCwd,\n    root: absoluteRootDir,\n    envName,\n    caller\n  };\n  const configChain = (0, _configChain.buildRootChain)(args, context);\n  if (!configChain) return null;\n  const options = {};\n  configChain.options.forEach(opts => {\n    (0, _util.mergeOptions)(options, opts);\n  });\n  options.babelrc = false;\n  options.configFile = false;\n  options.passPerPreset = false;\n  options.envName = context.envName;\n  options.cwd = context.cwd;\n  options.root = context.root;\n  options.filename = typeof context.filename === \"string\" ? context.filename : undefined;\n  options.plugins = configChain.plugins.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor));\n  options.presets = configChain.presets.map(descriptor => (0, _item.createItemFromDescriptor)(descriptor));\n  return {\n    options,\n    context,\n    ignore: configChain.ignore,\n    babelrc: configChain.babelrc,\n    config: configChain.config\n  };\n}\n\nfunction loadPartialConfig(inputOpts) {\n  const result = loadPrivatePartialConfig(inputOpts);\n  if (!result) return null;\n  const {\n    options,\n    babelrc,\n    ignore,\n    config\n  } = result;\n  (options.plugins || []).forEach(item => {\n    if (item.value instanceof _plugin.default) {\n      throw new Error(\"Passing cached plugin instances is not supported in \" + \"babel.loadPartialConfig()\");\n    }\n  });\n  return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined);\n}\n\nclass PartialConfig {\n  constructor(options, babelrc, ignore, config) {\n    this.options = options;\n    this.babelignore = ignore;\n    this.babelrc = babelrc;\n    this.config = config;\n    Object.freeze(this);\n  }\n\n  hasFilesystemConfig() {\n    return this.babelrc !== undefined || this.config !== undefined;\n  }\n\n}\n\nObject.freeze(PartialConfig.prototype);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformSync = transformSync;\nexports.transformAsync = transformAsync;\nexports.transform = void 0;\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _transformation = require(\"./transformation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst transform = function transform(code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) return transformSync(code, opts);\n  const cb = callback;\n  process.nextTick(() => {\n    let cfg;\n\n    try {\n      cfg = (0, _config.default)(opts);\n      if (cfg === null) return cb(null, null);\n    } catch (err) {\n      return cb(err);\n    }\n\n    (0, _transformation.runAsync)(cfg, code, null, cb);\n  });\n};\n\nexports.transform = transform;\n\nfunction transformSync(code, opts) {\n  const config = (0, _config.default)(opts);\n  if (config === null) return null;\n  return (0, _transformation.runSync)(config, code);\n}\n\nfunction transformAsync(code, opts) {\n  return new Promise((res, rej) => {\n    transform(code, opts, (err, result) => {\n      if (err == null) res(result);else rej(err);\n    });\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runAsync = runAsync;\nexports.runSync = runSync;\n\nfunction _traverse() {\n  const data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _pluginPass = _interopRequireDefault(require(\"./plugin-pass\"));\n\nvar _blockHoistPlugin = _interopRequireDefault(require(\"./block-hoist-plugin\"));\n\nvar _normalizeOpts = _interopRequireDefault(require(\"./normalize-opts\"));\n\nvar _normalizeFile = _interopRequireDefault(require(\"./normalize-file\"));\n\nvar _generate = _interopRequireDefault(require(\"./file/generate\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction runAsync(config, code, ast, callback) {\n  let result;\n\n  try {\n    result = runSync(config, code, ast);\n  } catch (err) {\n    return callback(err);\n  }\n\n  return callback(null, result);\n}\n\nfunction runSync(config, code, ast) {\n  const file = (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code, ast);\n  transformFile(file, config.passes);\n  const opts = file.opts;\n  const {\n    outputCode,\n    outputMap\n  } = opts.code !== false ? (0, _generate.default)(config.passes, file) : {};\n  return {\n    metadata: file.metadata,\n    options: opts,\n    ast: opts.ast === true ? file.ast : null,\n    code: outputCode === undefined ? null : outputCode,\n    map: outputMap === undefined ? null : outputMap,\n    sourceType: file.ast.program.sourceType\n  };\n}\n\nfunction transformFile(file, pluginPasses) {\n  for (const pluginPairs of pluginPasses) {\n    const passPairs = [];\n    const passes = [];\n    const visitors = [];\n\n    for (const plugin of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {\n      const pass = new _pluginPass.default(file, plugin.key, plugin.options);\n      passPairs.push([plugin, pass]);\n      passes.push(pass);\n      visitors.push(plugin.visitor);\n    }\n\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.pre;\n\n      if (fn) {\n        const result = fn.call(pass, file);\n\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .pre, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n\n    const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);\n\n    (0, _traverse().default)(file.ast, visitor, file.scope);\n\n    for (const [plugin, pass] of passPairs) {\n      const fn = plugin.post;\n\n      if (fn) {\n        const result = fn.call(pass, file);\n\n        if (isThenable(result)) {\n          throw new Error(`You appear to be using an plugin with an async .post, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n        }\n      }\n    }\n  }\n}\n\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass PluginPass {\n  constructor(file, key, options) {\n    this._map = new Map();\n    this.key = key;\n    this.file = file;\n    this.opts = options || {};\n    this.cwd = file.opts.cwd;\n    this.filename = file.opts.filename;\n  }\n\n  set(key, val) {\n    this._map.set(key, val);\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  availableHelper(name, versionRange) {\n    return this.file.availableHelper(name, versionRange);\n  }\n\n  addHelper(name) {\n    return this.file.addHelper(name);\n  }\n\n  addImport() {\n    return this.file.addImport();\n  }\n\n  getModuleName() {\n    return this.file.getModuleName();\n  }\n\n  buildCodeFrameError(node, msg, Error) {\n    return this.file.buildCodeFrameError(node, msg, Error);\n  }\n\n}\n\nexports.default = PluginPass;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = loadBlockHoistPlugin;\n\nfunction _sortBy() {\n  const data = _interopRequireDefault(require(\"lodash/sortBy\"));\n\n  _sortBy = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = _interopRequireDefault(require(\"../config\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet LOADED_PLUGIN;\n\nfunction loadBlockHoistPlugin() {\n  if (!LOADED_PLUGIN) {\n    const config = (0, _config.default)({\n      babelrc: false,\n      configFile: false,\n      plugins: [blockHoistPlugin]\n    });\n    LOADED_PLUGIN = config ? config.passes[0][0] : undefined;\n    if (!LOADED_PLUGIN) throw new Error(\"Assertion failure\");\n  }\n\n  return LOADED_PLUGIN;\n}\n\nconst blockHoistPlugin = {\n  name: \"internal.blockHoist\",\n  visitor: {\n    Block: {\n      exit({\n        node\n      }) {\n        let hasChange = false;\n\n        for (let i = 0; i < node.body.length; i++) {\n          const bodyNode = node.body[i];\n\n          if (bodyNode && bodyNode._blockHoist != null) {\n            hasChange = true;\n            break;\n          }\n        }\n\n        if (!hasChange) return;\n        node.body = (0, _sortBy().default)(node.body, function (bodyNode) {\n          let priority = bodyNode && bodyNode._blockHoist;\n          if (priority == null) priority = 1;\n          if (priority === true) priority = 2;\n          return -1 * priority;\n        });\n      }\n\n    }\n  }\n};","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeOptions;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction normalizeOptions(config) {\n  const {\n    filename,\n    cwd,\n    filenameRelative = typeof filename === \"string\" ? _path().default.relative(cwd, filename) : \"unknown\",\n    sourceType = \"module\",\n    inputSourceMap,\n    sourceMaps = !!inputSourceMap,\n    moduleRoot,\n    sourceRoot = moduleRoot,\n    sourceFileName = _path().default.basename(filenameRelative),\n    comments = true,\n    compact = \"auto\"\n  } = config.options;\n  const opts = config.options;\n  const options = Object.assign({}, opts, {\n    parserOpts: Object.assign({\n      sourceType: _path().default.extname(filenameRelative) === \".mjs\" ? \"module\" : sourceType,\n      sourceFileName: filename,\n      plugins: []\n    }, opts.parserOpts),\n    generatorOpts: Object.assign({\n      filename,\n      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n      retainLines: opts.retainLines,\n      comments,\n      shouldPrintComment: opts.shouldPrintComment,\n      compact,\n      minified: opts.minified,\n      sourceMaps,\n      sourceRoot,\n      sourceFileName\n    }, opts.generatorOpts)\n  });\n\n  for (const plugins of config.passes) {\n    for (const plugin of plugins) {\n      if (plugin.manipulateOptions) {\n        plugin.manipulateOptions(options, options.parserOpts);\n      }\n    }\n  }\n\n  return options;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cloneDeep() {\n  const data = _interopRequireDefault(require(\"lodash/cloneDeep\"));\n\n  _cloneDeep = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction t() {\n  const data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _parser() {\n  const data = require(\"@babel/parser\");\n\n  _parser = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _codeFrame() {\n  const data = require(\"@babel/code-frame\");\n\n  _codeFrame = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = _interopRequireDefault(require(\"./file/file\"));\n\nvar _missingPluginHelper = _interopRequireDefault(require(\"./util/missing-plugin-helper\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:transform:file\");\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n  let inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().default.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      try {\n        inputMap = _convertSourceMap().default.fromSource(code);\n\n        if (inputMap) {\n          code = _convertSourceMap().default.removeComments(code);\n        }\n      } catch (err) {\n        debug(\"discarding unknown inline input sourcemap\", err);\n        code = _convertSourceMap().default.removeComments(code);\n      }\n    }\n\n    if (!inputMap) {\n      if (typeof options.filename === \"string\") {\n        try {\n          inputMap = _convertSourceMap().default.fromMapFileSource(code, _path().default.dirname(options.filename));\n\n          if (inputMap) {\n            code = _convertSourceMap().default.removeMapFileComments(code);\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n          code = _convertSourceMap().default.removeMapFileComments(code);\n        }\n      } else {\n        debug(\"discarding un-loadable file input sourcemap\");\n        code = _convertSourceMap().default.removeMapFileComments(code);\n      }\n    }\n  }\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = t().file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    ast = (0, _cloneDeep().default)(ast);\n  } else {\n    ast = parser(pluginPasses, options, code);\n  }\n\n  return new _file.default(options, {\n    code,\n    ast,\n    inputMap\n  });\n}\n\nfunction parser(pluginPasses, {\n  parserOpts,\n  highlightCode = true,\n  filename = \"unknown\"\n}, code) {\n  try {\n    const results = [];\n\n    for (const plugins of pluginPasses) {\n      for (const plugin of plugins) {\n        const {\n          parserOverride\n        } = plugin;\n\n        if (parserOverride) {\n          const ast = parserOverride(code, parserOpts, _parser().parse);\n          if (ast !== undefined) results.push(ast);\n        }\n      }\n    }\n\n    if (results.length === 0) {\n      return (0, _parser().parse)(code, parserOpts);\n    } else if (results.length === 1) {\n      if (typeof results[0].then === \"function\") {\n        throw new Error(`You appear to be using an async codegen plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n      }\n\n      return results[0];\n    }\n\n    throw new Error(\"More than one plugin attempted to override parsing.\");\n  } catch (err) {\n    if (err.code === \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\") {\n      err.message += \"\\nConsider renaming the file to '.mjs', or setting sourceType:module \" + \"or sourceType:unambiguous in your Babel config for this file.\";\n    }\n\n    const {\n      loc,\n      missingPlugin\n    } = err;\n\n    if (loc) {\n      const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      }, {\n        highlightCode\n      });\n\n      if (missingPlugin) {\n        err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame);\n      } else {\n        err.message = `${filename}: ${err.message}\\n\\n` + codeFrame;\n      }\n\n      err.code = \"BABEL_PARSE_ERROR\";\n    }\n\n    throw err;\n  }\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateMissingPluginMessage;\nconst pluginNameMap = {\n  classProperties: {\n    syntax: {\n      name: \"@babel/plugin-syntax-class-properties\",\n      url: \"https://git.io/vb4yQ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-class-properties\",\n      url: \"https://git.io/vb4SL\"\n    }\n  },\n  decorators: {\n    syntax: {\n      name: \"@babel/plugin-syntax-decorators\",\n      url: \"https://git.io/vb4y9\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-decorators\",\n      url: \"https://git.io/vb4ST\"\n    }\n  },\n  doExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-do-expressions\",\n      url: \"https://git.io/vb4yh\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-do-expressions\",\n      url: \"https://git.io/vb4S3\"\n    }\n  },\n  dynamicImport: {\n    syntax: {\n      name: \"@babel/plugin-syntax-dynamic-import\",\n      url: \"https://git.io/vb4Sv\"\n    }\n  },\n  exportDefaultFrom: {\n    syntax: {\n      name: \"@babel/plugin-syntax-export-default-from\",\n      url: \"https://git.io/vb4SO\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-export-default-from\",\n      url: \"https://git.io/vb4yH\"\n    }\n  },\n  exportNamespaceFrom: {\n    syntax: {\n      name: \"@babel/plugin-syntax-export-namespace-from\",\n      url: \"https://git.io/vb4Sf\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-export-namespace-from\",\n      url: \"https://git.io/vb4SG\"\n    }\n  },\n  flow: {\n    syntax: {\n      name: \"@babel/plugin-syntax-flow\",\n      url: \"https://git.io/vb4yb\"\n    },\n    transform: {\n      name: \"@babel/plugin-transform-flow-strip-types\",\n      url: \"https://git.io/vb49g\"\n    }\n  },\n  functionBind: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-bind\",\n      url: \"https://git.io/vb4y7\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-bind\",\n      url: \"https://git.io/vb4St\"\n    }\n  },\n  functionSent: {\n    syntax: {\n      name: \"@babel/plugin-syntax-function-sent\",\n      url: \"https://git.io/vb4yN\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-function-sent\",\n      url: \"https://git.io/vb4SZ\"\n    }\n  },\n  importMeta: {\n    syntax: {\n      name: \"@babel/plugin-syntax-import-meta\",\n      url: \"https://git.io/vbKK6\"\n    }\n  },\n  jsx: {\n    syntax: {\n      name: \"@babel/plugin-syntax-jsx\",\n      url: \"https://git.io/vb4yA\"\n    },\n    transform: {\n      name: \"@babel/plugin-transform-react-jsx\",\n      url: \"https://git.io/vb4yd\"\n    }\n  },\n  logicalAssignment: {\n    syntax: {\n      name: \"@babel/plugin-syntax-logical-assignment-operators\",\n      url: \"https://git.io/vAlBp\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-logical-assignment-operators\",\n      url: \"https://git.io/vAlRe\"\n    }\n  },\n  nullishCoalescingOperator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-nullish-coalescing-operator\",\n      url: \"https://git.io/vb4yx\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-nullish-coalescing-operator\",\n      url: \"https://git.io/vb4Se\"\n    }\n  },\n  numericSeparator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-numeric-separator\",\n      url: \"https://git.io/vb4Sq\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-numeric-separator\",\n      url: \"https://git.io/vb4yS\"\n    }\n  },\n  optionalChaining: {\n    syntax: {\n      name: \"@babel/plugin-syntax-optional-chaining\",\n      url: \"https://git.io/vb4Sc\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-optional-chaining\",\n      url: \"https://git.io/vb4Sk\"\n    }\n  },\n  pipelineOperator: {\n    syntax: {\n      name: \"@babel/plugin-syntax-pipeline-operator\",\n      url: \"https://git.io/vb4yj\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-pipeline-operator\",\n      url: \"https://git.io/vb4SU\"\n    }\n  },\n  throwExpressions: {\n    syntax: {\n      name: \"@babel/plugin-syntax-throw-expressions\",\n      url: \"https://git.io/vb4SJ\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-throw-expressions\",\n      url: \"https://git.io/vb4yF\"\n    }\n  },\n  typescript: {\n    syntax: {\n      name: \"@babel/plugin-syntax-typescript\",\n      url: \"https://git.io/vb4SC\"\n    },\n    transform: {\n      name: \"@babel/plugin-transform-typescript\",\n      url: \"https://git.io/vb4Sm\"\n    }\n  },\n  asyncGenerators: {\n    syntax: {\n      name: \"@babel/plugin-syntax-async-generators\",\n      url: \"https://git.io/vb4SY\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-async-generator-functions\",\n      url: \"https://git.io/vb4yp\"\n    }\n  },\n  objectRestSpread: {\n    syntax: {\n      name: \"@babel/plugin-syntax-object-rest-spread\",\n      url: \"https://git.io/vb4y5\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-object-rest-spread\",\n      url: \"https://git.io/vb4Ss\"\n    }\n  },\n  optionalCatchBinding: {\n    syntax: {\n      name: \"@babel/plugin-syntax-optional-catch-binding\",\n      url: \"https://git.io/vb4Sn\"\n    },\n    transform: {\n      name: \"@babel/plugin-proposal-optional-catch-binding\",\n      url: \"https://git.io/vb4SI\"\n    }\n  }\n};\n\nconst getNameURLCombination = ({\n  name,\n  url\n}) => `${name} (${url})`;\n\nfunction generateMissingPluginMessage(missingPluginName, loc, codeFrame) {\n  let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled ` + `(${loc.line}:${loc.column + 1}):\\n\\n` + codeFrame;\n  const pluginInfo = pluginNameMap[missingPluginName];\n\n  if (pluginInfo) {\n    const {\n      syntax: syntaxPlugin,\n      transform: transformPlugin\n    } = pluginInfo;\n\n    if (syntaxPlugin) {\n      if (transformPlugin) {\n        const transformPluginInfo = getNameURLCombination(transformPlugin);\n        helpMessage += `\\n\\nAdd ${transformPluginInfo} to the 'plugins' section of your Babel config ` + `to enable transformation.`;\n      } else {\n        const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);\n        helpMessage += `\\n\\nAdd ${syntaxPluginInfo} to the 'plugins' section of your Babel config ` + `to enable parsing.`;\n      }\n    }\n  }\n\n  return helpMessage;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateCode;\n\nfunction _convertSourceMap() {\n  const data = _interopRequireDefault(require(\"convert-source-map\"));\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _generator() {\n  const data = _interopRequireDefault(require(\"@babel/generator\"));\n\n  _generator = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _mergeMap = _interopRequireDefault(require(\"./merge-map\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction generateCode(pluginPasses, file) {\n  const {\n    opts,\n    ast,\n    code,\n    inputMap\n  } = file;\n  const results = [];\n\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const {\n        generatorOverride\n      } = plugin;\n\n      if (generatorOverride) {\n        const result = generatorOverride(ast, opts.generatorOpts, code, _generator().default);\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n\n  let result;\n\n  if (results.length === 0) {\n    result = (0, _generator().default)(ast, opts.generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n\n    if (typeof result.then === \"function\") {\n      throw new Error(`You appear to be using an async parser plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n\n  let {\n    code: outputCode,\n    map: outputMap\n  } = result;\n\n  if (outputMap && inputMap) {\n    outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap);\n  }\n\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + _convertSourceMap().default.fromObject(outputMap).toComment();\n  }\n\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n\n  return {\n    outputCode,\n    outputMap\n  };\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\n\nfunction _sourceMap() {\n  const data = _interopRequireDefault(require(\"source-map\"));\n\n  _sourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction mergeSourceMap(inputMap, map) {\n  const input = buildMappingData(inputMap);\n  const output = buildMappingData(map);\n  const mergedGenerator = new (_sourceMap().default.SourceMapGenerator)();\n\n  for (const _ref of input.sources) {\n    const {\n      source\n    } = _ref;\n\n    if (typeof source.content === \"string\") {\n      mergedGenerator.setSourceContent(source.path, source.content);\n    }\n  }\n\n  if (output.sources.length === 1) {\n    const defaultSource = output.sources[0];\n    const insertedMappings = new Map();\n    eachInputGeneratedRange(input, (generated, original, source) => {\n      eachOverlappingGeneratedOutputRange(defaultSource, generated, item => {\n        const key = makeMappingKey(item);\n        if (insertedMappings.has(key)) return;\n        insertedMappings.set(key, item);\n        mergedGenerator.addMapping({\n          source: source.path,\n          original: {\n            line: original.line,\n            column: original.columnStart\n          },\n          generated: {\n            line: item.line,\n            column: item.columnStart\n          },\n          name: original.name\n        });\n      });\n    });\n\n    for (const item of insertedMappings.values()) {\n      if (item.columnEnd === Infinity) {\n        continue;\n      }\n\n      const clearItem = {\n        line: item.line,\n        columnStart: item.columnEnd\n      };\n      const key = makeMappingKey(clearItem);\n\n      if (insertedMappings.has(key)) {\n        continue;\n      }\n\n      mergedGenerator.addMapping({\n        generated: {\n          line: clearItem.line,\n          column: clearItem.columnStart\n        }\n      });\n    }\n  }\n\n  const result = mergedGenerator.toJSON();\n\n  if (typeof input.sourceRoot === \"string\") {\n    result.sourceRoot = input.sourceRoot;\n  }\n\n  return result;\n}\n\nfunction makeMappingKey(item) {\n  return `${item.line}/${item.columnStart}`;\n}\n\nfunction eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {\n  const overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);\n\n  for (const _ref2 of overlappingOriginal) {\n    const {\n      generated\n    } = _ref2;\n\n    for (const item of generated) {\n      callback(item);\n    }\n  }\n}\n\nfunction filterApplicableOriginalRanges({\n  mappings\n}, {\n  line,\n  columnStart,\n  columnEnd\n}) {\n  return filterSortedArray(mappings, ({\n    original: outOriginal\n  }) => {\n    if (line > outOriginal.line) return -1;\n    if (line < outOriginal.line) return 1;\n    if (columnStart >= outOriginal.columnEnd) return -1;\n    if (columnEnd <= outOriginal.columnStart) return 1;\n    return 0;\n  });\n}\n\nfunction eachInputGeneratedRange(map, callback) {\n  for (const _ref3 of map.sources) {\n    const {\n      source,\n      mappings\n    } = _ref3;\n\n    for (const _ref4 of mappings) {\n      const {\n        original,\n        generated\n      } = _ref4;\n\n      for (const item of generated) {\n        callback(item, original, source);\n      }\n    }\n  }\n}\n\nfunction buildMappingData(map) {\n  const consumer = new (_sourceMap().default.SourceMapConsumer)(Object.assign({}, map, {\n    sourceRoot: null\n  }));\n  const sources = new Map();\n  const mappings = new Map();\n  let last = null;\n  consumer.computeColumnSpans();\n  consumer.eachMapping(m => {\n    if (m.originalLine === null) return;\n    let source = sources.get(m.source);\n\n    if (!source) {\n      source = {\n        path: m.source,\n        content: consumer.sourceContentFor(m.source, true)\n      };\n      sources.set(m.source, source);\n    }\n\n    let sourceData = mappings.get(source);\n\n    if (!sourceData) {\n      sourceData = {\n        source,\n        mappings: []\n      };\n      mappings.set(source, sourceData);\n    }\n\n    const obj = {\n      line: m.originalLine,\n      columnStart: m.originalColumn,\n      columnEnd: Infinity,\n      name: m.name\n    };\n\n    if (last && last.source === source && last.mapping.line === m.originalLine) {\n      last.mapping.columnEnd = m.originalColumn;\n    }\n\n    last = {\n      source,\n      mapping: obj\n    };\n    sourceData.mappings.push({\n      original: obj,\n      generated: consumer.allGeneratedPositionsFor({\n        source: m.source,\n        line: m.originalLine,\n        column: m.originalColumn\n      }).map(item => ({\n        line: item.line,\n        columnStart: item.column,\n        columnEnd: item.lastColumn + 1\n      }))\n    });\n  }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);\n  return {\n    file: map.file,\n    sourceRoot: map.sourceRoot,\n    sources: Array.from(mappings.values())\n  };\n}\n\nfunction findInsertionLocation(array, callback) {\n  let left = 0;\n  let right = array.length;\n\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    const item = array[mid];\n    const result = callback(item);\n\n    if (result === 0) {\n      left = mid;\n      break;\n    }\n\n    if (result >= 0) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  let i = left;\n\n  if (i < array.length) {\n    while (i >= 0 && callback(array[i]) >= 0) {\n      i--;\n    }\n\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction filterSortedArray(array, callback) {\n  const start = findInsertionLocation(array, callback);\n  const results = [];\n\n  for (let i = start; i < array.length && callback(array[i]) === 0; i++) {\n    results.push(array[i]);\n  }\n\n  return results;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFileSync = transformFileSync;\nexports.transformFileAsync = transformFileAsync;\nexports.transformFile = void 0;\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _transformation = require(\"./transformation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n({});\n\nconst transformFile = function transformFile(filename, opts, callback) {\n  let options;\n\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (opts == null) {\n    options = {\n      filename\n    };\n  } else if (opts && typeof opts === \"object\") {\n    options = Object.assign({}, opts, {\n      filename\n    });\n  }\n\n  process.nextTick(() => {\n    let cfg;\n\n    try {\n      cfg = (0, _config.default)(options);\n      if (cfg === null) return callback(null, null);\n    } catch (err) {\n      return callback(err);\n    }\n\n    const config = cfg;\n\n    _fs().default.readFile(filename, \"utf8\", function (err, code) {\n      if (err) return callback(err, null);\n      (0, _transformation.runAsync)(config, code, null, callback);\n    });\n  });\n};\n\nexports.transformFile = transformFile;\n\nfunction transformFileSync(filename, opts) {\n  let options;\n\n  if (opts == null) {\n    options = {\n      filename\n    };\n  } else if (opts && typeof opts === \"object\") {\n    options = Object.assign({}, opts, {\n      filename\n    });\n  }\n\n  const config = (0, _config.default)(options);\n  if (config === null) return null;\n  return (0, _transformation.runSync)(config, _fs().default.readFileSync(filename, \"utf8\"));\n}\n\nfunction transformFileAsync(filename, opts) {\n  return new Promise((res, rej) => {\n    transformFile(filename, opts, (err, result) => {\n      if (err == null) res(result);else rej(err);\n    });\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformFromAstSync = transformFromAstSync;\nexports.transformFromAstAsync = transformFromAstAsync;\nexports.transformFromAst = void 0;\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _transformation = require(\"./transformation\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst transformFromAst = function transformFromAst(ast, code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) return transformFromAstSync(ast, code, opts);\n  const cb = callback;\n  process.nextTick(() => {\n    let cfg;\n\n    try {\n      cfg = (0, _config.default)(opts);\n      if (cfg === null) return cb(null, null);\n    } catch (err) {\n      return cb(err);\n    }\n\n    if (!ast) return cb(new Error(\"No AST given\"));\n    (0, _transformation.runAsync)(cfg, code, ast, cb);\n  });\n};\n\nexports.transformFromAst = transformFromAst;\n\nfunction transformFromAstSync(ast, code, opts) {\n  const config = (0, _config.default)(opts);\n  if (config === null) return null;\n  if (!ast) throw new Error(\"No AST given\");\n  return (0, _transformation.runSync)(config, code, ast);\n}\n\nfunction transformFromAstAsync(ast, code, opts) {\n  return new Promise((res, rej) => {\n    transformFromAst(ast, code, opts, (err, result) => {\n      if (err == null) res(result);else rej(err);\n    });\n  });\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSync = parseSync;\nexports.parseAsync = parseAsync;\nexports.parse = void 0;\n\nvar _config = _interopRequireDefault(require(\"./config\"));\n\nvar _normalizeFile = _interopRequireDefault(require(\"./transformation/normalize-file\"));\n\nvar _normalizeOpts = _interopRequireDefault(require(\"./transformation/normalize-opts\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst parse = function parse(code, opts, callback) {\n  if (typeof opts === \"function\") {\n    callback = opts;\n    opts = undefined;\n  }\n\n  if (callback === undefined) return parseSync(code, opts);\n  const config = (0, _config.default)(opts);\n\n  if (config === null) {\n    return null;\n  }\n\n  const cb = callback;\n  process.nextTick(() => {\n    let ast = null;\n\n    try {\n      const cfg = (0, _config.default)(opts);\n      if (cfg === null) return cb(null, null);\n      ast = (0, _normalizeFile.default)(cfg.passes, (0, _normalizeOpts.default)(cfg), code).ast;\n    } catch (err) {\n      return cb(err);\n    }\n\n    cb(null, ast);\n  });\n};\n\nexports.parse = parse;\n\nfunction parseSync(code, opts) {\n  const config = (0, _config.default)(opts);\n\n  if (config === null) {\n    return null;\n  }\n\n  return (0, _normalizeFile.default)(config.passes, (0, _normalizeOpts.default)(config), code).ast;\n}\n\nfunction parseAsync(code, opts) {\n  return new Promise((res, rej) => {\n    parse(code, opts, (err, result) => {\n      if (err == null) res(result);else rej(err);\n    });\n  });\n}"]}